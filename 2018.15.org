#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 15
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2018-15)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2018-15
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-15)
#+END_SRC
** Input
This is an "oh jeez" one. The input isn't bad, a simple grid where:
- =#= :: wall
- =.= :: open space
- =G= :: goblin
- =E= :: elf

The map is parsed into a struct consisting of all open cavern spaces,
elves, and goblins. I've let the health and attack power be
parameters.

#+NAME: parse-map
#+BEGIN_SRC lisp :results silent
  (defun parse-map (lines &optional (goblin-hp 200) (goblin-ap 3) (elf-hp 200) (elf-ap 3))
    (let ((maxx (length (car lines)))
          (maxy (length lines))
          (elves (make-hash-table))
          (goblins (make-hash-table))
          (grid (make-hash-table)))
      (iter (for y from 0)
            (for line in lines)
            (iter (for x from 0)
                  (for c in-string line)
                  (case c
                    (#\. (setf (gethash (complex x y) grid) t))
                    (#\G (setf (gethash (complex x y) grid) t)
                     (setf (gethash (complex x y) goblins)
                           (make-player :kind :goblin :position (complex x y) :hp goblin-hp :ap goblin-ap)))
                    (#\E (setf (gethash (complex x y) grid) t)
                     (setf (gethash (complex x y) elves)
                           (make-player :kind :elf :position (complex x y) :hp elf-hp :ap elf-ap)))
                    (otherwise nil))))
      (make-game :grid grid :elves elves :goblins goblins :maxx maxx :maxy maxy :round 0)))
#+END_SRC

I'm going to represent the game with a simple struct: three hashtables
and the max x and y coordinates from the input (useful for printing out).

#+NAME: game-struct
#+BEGIN_SRC lisp :results silent
  (defstruct game
    grid
    elves
    goblins
    maxx
    maxy
    round)
  (defstruct player
    kind
    position
    hp
    ap)
#+END_SRC

#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (parse-map (read-input "input/15.txt")))
#+END_SRC
** Part 1
All order ties are in "reading order". Since complex numbers aren't
directly comparable (for sorting), I'll make a function that can
compare them and pass that to =sort=. You can use any key, by default
this will just sort a list of complex numbers.

#+NAME: reading-order
#+BEGIN_SRC lisp :results silent
  (defun reading-order (list &key (key #'identity))
    (flet ((complex<= (c1 c2)
             (or (< (imagpart c1) (imagpart c2))
                 (and (= (imagpart c1) (imagpart c2))
                      (< (realpart c1) (realpart c2)))
                 (= c1 c2))))
      (sort list #'complex<= :key key)))
#+END_SRC

Distance is Manhattan (city block) distance.
#+NAME: manhattan-distance
#+BEGIN_SRC lisp :results silent
  (defun manhattan-distance (p1 p2)
    (+ (abs (imagpart (- p1 p2)))
       (abs (realpart (- p1 p2)))))
#+END_SRC

I needed this utility function often enough that I decided to make it
its own thing. Given a position and a table with keys that are also
complex number encoded positions, this will return the 4 neighbors (if
they exist).

#+NAME: get-neighbors
#+BEGIN_SRC lisp :results silent
  (defun get-neighbors (position table)
    (iter (repeat 4)
          (with offset = 1)
          (when (gethash (+ position offset) table)
            (collect (gethash (+ position offset) table)))
          (setf offset (* offset #C(0 1)))))
#+END_SRC

I should add these to a library, I've needed them for several problems
now.

I also want to be able to print the grid, for debugging purposes.
#+NAME: print-grid
#+BEGIN_SRC lisp :results silent
  (defun print-grid (game)
    (format t "Round #~d~%" (game-round game))
    (let ((goblins (game-goblins game))
          (elves (game-elves game))
          (grid (game-grid game)))
      (iter (for y from 0 below (game-maxy game))
            (for players-in-row = nil)
            (iter (for x from 0 below (game-maxx game))
                  (let ((coord (complex x y)))
                    (cond ((null (gethash coord grid))
                           (format t "#"))
                          ((gethash coord goblins)
                           (format t "G")
                           (push (gethash coord goblins) players-in-row))
                          ((gethash coord elves)
                           (format t "E")
                           (push (gethash coord elves) players-in-row))
                          (t (format t ".")))))
            (iter (for p in players-in-row)
                  (case (player-kind p)
                    (:elf (format t " (E ~d ~d)" (player-hp p) (player-ap p)))
                    (:goblin (format t " (G ~d ~d)" (player-hp p) (player-ap p)))))
            (format t "~%"))
      (format t "Elf HP: ~d~%"
              (iter (for (k v) in-hashtable elves)
                    (sum (player-hp v))))
      (format t "Goblin HP: ~d~%"
              (iter (for (k v) in-hashtable goblins)
                    (sum (player-hp v))))))
#+END_SRC

Some rules for the game:

1. Attacks only happen horizontally and vertically, preference to
   reading order when there are mulitple options.
2. Movement only happens horizontally and vertically, preference to
   reading order when there are mulitple options.
3. If a combatant is adjacent to an enemy at the start of their turn,
   they attack.
   1. Attacks are againts the opponents HP, reduced by the combatants
      attack power.
4. If no adjacent combatants, the creature will find the nearest enemy
   and move towards them, preference again given to reading order when
   they have multiple enemies they may prefer.
5. The game ends when any combatant finds that they've wiped out the enemy.
6. *Rounds* end when all combatants have gone, so the game can end in
   the middle of a round for counting purposes.
7. The desired result for Part 1 is the number of *full* rounds
   multiplied by the sum of the HP of the survivors.

#+NAME: attack
#+BEGIN_SRC lisp :results silent
  (defun attack (attacker victim)
    (decf (player-hp victim) (player-ap attacker)))
#+END_SRC


All this code below is getting unwieldy, I'm going to start breaking
it into chunks which can be described and reasoned about more easily.

For convenience, I'm pulling these variables out of the game state so
referencing them isn't so cumbersome.
#+NAME: execute-round-let-block
#+BEGIN_SRC lisp :results silent
  (combatants nil)
  (goblins (game-goblins game))
  (elves (game-elves game))
#+END_SRC

We need a list of all combatants, regardless of their kind.
#+NAME: collect-combatants
#+BEGIN_SRC lisp :results silent
  (iter (for (k v) in-hashtable goblins)
        (push v combatants))
  (iter (for (k v) in-hashtable elves)
        (push v combatants))
#+END_SRC

Sort the combatants once so we can then execute over the list in order
without having to reexamine it later.
#+NAME: sort-combatants
#+BEGIN_SRC lisp :results silent
  (setf combatants (reading-order combatants :key #'player-position))
#+END_SRC

This is the main kernel of the game loop. My first version of player
movement got unwieldy, so I cleared it all out and now I'm starting
over.
#+NAME: execute-round
#+BEGIN_SRC lisp :results silent :noweb yes
  (defun execute-round (game)
    (let (
          <<execute-round-let-block>>
          )
      <<collect-combatants>>
      <<sort-combatants>>
      (iter (while combatants)
            ;; Get the current combatant
            (let* ((current (pop combatants))
                   (enemies (case (player-kind current)
                              (:goblin elves)
                              (:elf goblins)))
                   (allies (case (player-kind current)
                             (:goblin goblins)
                             (:elf elves)))
                   (position (player-position current))
                   ;; Get all their enemies (if any).
                   (neighbors (reading-order (get-neighbors position enemies) :key #'player-position)))
              ;; Combatants will *attack* their first (reading-order)
              ;; neighbor, if any. That is their entire turn.
              ;; The round terminates early, and doesn't increment the
              ;; round number, if a combatant finds that it has no
              ;; enemies.
              (when (= 0 (hash-table-count enemies))
                (return nil))
              ;; I'm putting this first, to capture movement. Because
              ;; after movement there is an attack if they've moved in
              ;; range of an enemy.
              (unless neighbors
                (move-player current game))
              ;; Second time calculating neighbors, but this is because
              ;; the players position may have been updated.
              (setf neighbors (reading-order (get-neighbors (player-position current) enemies) :key #'player-position))
              (when neighbors
                ;; Neighbors are already sorted so get the first.
                (let ((victim (car neighbors)))
                  ;; Attack them
                  (attack current victim)
                  ;; If the victim's health drops to 0 or lower
                  (when (<= (player-hp victim) 0)
                    ;; Remove the victim from the list of potential
                    ;; combatants (needed if they haven't taken a turn
                    ;; yet)
                    (setf combatants (remove (player-position victim) combatants
                                             :key #'player-position))
                    ;; Remove the victim from their hash table so no one
                    ;; else attempts to attack them, and they're removed
                    ;; from future rounds.
                    (remhash (player-position victim) enemies))))
            ;; If the while loop terminates normally then we return t to
            ;; indicate that the game can continue, and we increment the
            ;; round count.
            (finally (incf (game-round game))
                     (return t))))))
              ;; If there are no enemies adjacent to the current
              ;; attacker, they have to move.
              ;; I'll do that later, let's test the attack logic.
#+END_SRC

This is the part that stumped me before. I had parts of it, but it was
too cumbersome to debug. The problem I ran into was that I was letting
the players get caught up in loops with poor pathfinding. They need to
actually move along a path towards the enemy, not just to the closest
position (which is what I did the first time). I tore that all out,
here's v2.
#+NAME: move-player
#+BEGIN_SRC lisp :results silent
  (defun move-player (player game)
    (let ((enemies (case (player-kind player)
                     (:goblin (game-elves game))
                     (:elf (game-goblins game))))
          (allies (case (player-kind player)
                    (:elf (game-elves game))
                    (:goblin (game-goblins game))))
          (position (player-position player)))
      nil))
#+END_SRC

#+NAME: run-game
#+BEGIN_SRC lisp :results silent
  (defun run-game (game &optional (round-limit 1000))
    (print-grid game)
    (iter (while (execute-round game))
          (for i from 0 below round-limit))
    (print-grid game))
#+END_SRC

#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 15 A: ~a~%" (run-game *input*)))
#+END_SRC
** Part 2
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b () (format t "Problem 15 B: ~a~%" (identity *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent
  <<game-struct>>
#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<read-input>>
  <<parse-map>>
  <<reading-order>>
  <<print-grid>>
  <<manhattan-distance>>
  <<attack>>
  <<execute-round>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.15.lisp
  (defparameter *debug* nil)
  <<structs>>
  <<initialize>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
#+begin_example
Round #0
################################
##########..........############
########G..................##### (G 200 3)
#######..G.GG...............#### (G 200 3) (G 200 3) (G 200 3)
#######....G.......#......###### (G 200 3)
########.G.G...............#E..# (E 200 3) (G 200 3) (G 200 3)
#######G.................#.....# (G 200 3)
########.......................#
########G.....G....#.....##....# (G 200 3) (G 200 3)
########.....#....G.........#### (G 200 3)
#########..........##....E.E#.## (E 200 3) (E 200 3)
##########G..G..........#####.## (G 200 3) (G 200 3)
##########....#####G....####E.## (E 200 3) (G 200 3)
######....G..#######.....#.....# (G 200 3)
###....#....#########......#####
####........#########..E...##### (E 200 3)
###.........#########......#####
####G....G..#########......##### (G 200 3) (G 200 3)
####..#.....#########....#######
######.......#######...E.####### (E 200 3)
###.G.....E.G.#####.....######## (G 200 3) (E 200 3) (G 200 3)
#.....G........E.......######### (E 200 3) (G 200 3)
#......#..#..####....#.#########
#...#.........###.#..###########
##............###..#############
######.....E####..############## (E 200 3)
######...........###############
#######....E....################ (E 200 3)
######...####...################
######...###....################
###.....###..##..###############
################################
Elf HP: 2000
Goblin HP: 4000
Round #1001
################################
##########..........############
########G..................##### (G 200 3)
#######..G.GG...............#### (G 200 3) (G 200 3) (G 200 3)
#######....G.......#......###### (G 200 3)
########.G.G...............#E..# (E 200 3) (G 200 3) (G 200 3)
#######G.................#.....# (G 200 3)
########.......................#
########G.....G....#.....##....# (G 200 3) (G 200 3)
########.....#....G.........#### (G 200 3)
#########..........##....E.E#.## (E 200 3) (E 200 3)
##########G..G..........#####.## (G 200 3) (G 200 3)
##########....#####G....####E.## (E 200 3) (G 200 3)
######....G..#######.....#.....# (G 200 3)
###....#....#########......#####
####........#########..E...##### (E 200 3)
###.........#########......#####
####G....G..#########......##### (G 200 3) (G 200 3)
####..#.....#########....#######
######.......#######...E.####### (E 200 3)
###.G.....E.G.#####.....######## (G 200 3) (E 200 3) (G 200 3)
#.....G........E.......######### (E 200 3) (G 200 3)
#......#..#..####....#.#########
#...#.........###.#..###########
##............###..#############
######.....E####..############## (E 200 3)
######...........###############
#######....E....################ (E 200 3)
######...####...################
######...###....################
###.....###..##..###############
################################
Elf HP: 2000
Goblin HP: 4000
Problem 15 A: NIL
Problem 15 B: #S(GAME
                 :GRID #<HASH-TABLE :TEST EQL :COUNT 448 {100181EC53}>
                 :ELVES #<HASH-TABLE :TEST EQL :COUNT 10 {10056E7A93}>
                 :GOBLINS #<HASH-TABLE :TEST EQL :COUNT 20 {10056E7EB3}>
                 :MAXX 32
                 :MAXY 32
                 :ROUND 1001)
#+end_example
** Test Cases

Some simple grids to test printing and single round advancement.

#+NAME: single-round-combat
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "######"
                               "#.GE.#"
                               "#....#"
                               "######"))))
    (print-grid game)
    (execute-round game)
    (print-grid game))
#+END_SRC

Expected result: both start at 200 HP, both end at 197 HP.

#+RESULTS: single-round-combat
#+begin_example
Round #0
######
#.GE.# (E 200 3) (G 200 3)
#....#
######
Elf HP: 200
Goblin HP: 200
Round #1
######
#.GE.# (E 197 3) (G 197 3)
#....#
######
Elf HP: 197
Goblin HP: 197
#+end_example

#+NAME: full-round-combat
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "######"
                               "#.GE.#"
                               "#....#"
                               "######"))))
    (run-game game))
#+END_SRC

The goblin should survive, and he does. He wins because he hits
first.
#+RESULTS: full-round-combat
#+begin_example
Round #0
######
#.GE.# (E 200 3) (G 200 3)
#....#
######
Elf HP: 200
Goblin HP: 200
Round #67
######
#.G..# (G 2 3)
#....#
######
Elf HP: 0
Goblin HP: 2
#+end_example

#+NAME: two-on-one-combat
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "######"
                               "#.GE.#"
                               "#..G.#"
                               "######"))))
    (run-game game))
#+END_SRC

Expected: Elf dies after 200/6 rounds (rounded down, so round 33). Top
Goblin has HP reduced by 3 33 times to 101 HP. Bottom Goblin has full
health. This gives me confidence my round count is correct.
#+RESULTS: two-on-one-combat
#+begin_example
Round #0
######
#.GE.# (E 200 3) (G 200 3)
#..G.# (G 200 3)
######
Elf HP: 200
Goblin HP: 400
Round #33
######
#.G..# (G 101 3)
#..G.# (G 200 3)
######
Elf HP: 0
Goblin HP: 301
#+end_example

#+NAME: single-movement
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "######"
                               "#..G.#"
                               "#....#"
                               "#..E.#"
                               "######"))))
    (run-game game))
#+END_SRC

Expected: The Goblin moves one south, and is attacked on that same
round by the ELf. This gives the Elf the advantage of first attack and
he wins after 67 rounds.
#+RESULTS: single-movement
#+begin_example
Round #0
######
#..G.# (G 200 3)
#....#
#..E.# (E 200 3)
######
Elf HP: 200
Goblin HP: 200
Round #1001
######
#..G.# (G 200 3)
#....#
#..E.# (E 200 3)
######
Elf HP: 200
Goblin HP: 200
#+end_example

#+NAME: tc-18740
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "#########"
                               "#G......#"
                               "#.E.#...#"
                               "#..##..G#"
                               "#...##..#"
                               "#...#...#"
                               "#.G...G.#"
                               "#.....G.#"
                               "#########"))))
        (run-game game))
#+END_SRC

#+RESULTS: tc-18740
#+begin_example
Round #0
#########
#G......# (G 200 3)
#.E.#...# (E 200 3)
#..##..G# (G 200 3)
#...##..#
#...#...#
#.G...G.# (G 200 3) (G 200 3)
#.....G.# (G 200 3)
#########
Elf HP: 200
Goblin HP: 1000
Round #1001
#########
#G......# (G 200 3)
#.E.#...# (E 200 3)
#..##..G# (G 200 3)
#...##..#
#...#...#
#.G...G.# (G 200 3) (G 200 3)
#.....G.# (G 200 3)
#########
Elf HP: 200
Goblin HP: 1000
#+end_example

#+NAME: complex-movement-example
#+BEGIN_SRC lisp :results output :exports both
  (let ((game (parse-map (list "#########"
                               "#G..G..G#"
                               "#.......#"
                               "#.......#"
                               "#G..E..G#"
                               "#.......#"
                               "#.......#"
                               "#G..G..G#"
                               "#########"))))
    (iter (repeat 4)
          (print-grid game)
          (execute-round game))
    (print-grid game))
#+END_SRC

#+RESULTS: complex-movement-example
#+begin_example
Round #0
#########
#G..G..G# (G 200 3) (G 200 3) (G 200 3)
#.......#
#.......#
#G..E..G# (G 200 3) (E 200 3) (G 200 3)
#.......#
#.......#
#G..G..G# (G 200 3) (G 200 3) (G 200 3)
#########
Elf HP: 200
Goblin HP: 1600
Round #1
#########
#.....G.# (G 200 3)
#G..G...# (G 197 3) (G 200 3)
#...E..G# (G 200 3) (E 200 3)
#.G.....# (G 200 3)
#.......#
#G..G..G# (G 200 3) (G 200 3) (G 200 3)
#.......#
#########
Elf HP: 200
Goblin HP: 1597
Round #2
#########
#....G..# (G 200 3)
#...G...# (G 194 3)
#GG.E.G.# (G 200 3) (E 197 3) (G 200 3) (G 200 3)
#.......#
#G..G..G# (G 200 3) (G 200 3) (G 200 3)
#.......#
#.......#
#########
Elf HP: 197
Goblin HP: 1594
Round #3
#########
#.......#
#G..GG..# (G 200 3) (G 191 3) (G 200 3)
#..GEG..# (G 200 3) (E 185 3) (G 200 3)
#G..G...# (G 200 3) (G 200 3)
#......G# (G 200 3)
#.......#
#.......#
#########
Elf HP: 185
Goblin HP: 1591
Round #4
#########
#.......#
#G..GG..# (G 200 3) (G 188 3) (G 200 3)
#..GEG..# (G 200 3) (E 173 3) (G 200 3)
#G..G...# (G 200 3) (G 200 3)
#......G# (G 200 3)
#.......#
#.......#
#########
Elf HP: 173
Goblin HP: 1588
#+end_example

#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  (def-suite aoc.2018.15)
  (in-suite aoc.2018.15)

  (test manhattan
    (is (= 0 (manhattan-distance (complex 0 0) (complex 0 0))))
    (is (= 1 (manhattan-distance (complex 0 1) (complex 0 0))))
    (is (= 3 (manhattan-distance (complex 1 1) (complex 3 0)))))

  (test reading-order
    (is (equal `((#C(0 0) 4) (#C(1 1) 3))
               (reading-order '((#C(1 1) 3) (#C(0 0) 4))))))

  (run! 'aoc.2018.15)
#+END_SRC
** Test Results
#+RESULTS: test-cases
: 
: Running test suite AOC.2018.15
:  Running test MANHATTAN ...
:  Running test READING-ORDER .
:  Did 4 checks.
:     Pass: 4 (100%)
:     Skip: 0 ( 0%)
:     Fail: 0 ( 0%)
** Thoughts
