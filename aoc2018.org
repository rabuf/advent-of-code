#+STARTUP: indent
#+OPTIONS: toc:nil num:nil
* Advent of Code 2018 [1/25]
This will be my attempt to solve the various Advent of Code 2018
problems with Common Lisp.
** DONE Day 1
[[https://adventofcode.com/2018/day/1][Problem Description]]
*** Input
The input for this one is a file with a number per line in the format
=(+|-)[0-9]+=. Common Lisp can read each line directly to a string. I
then had it parse each line into an integer directly.
#+NAME: day1-input
#+BEGIN_SRC lisp
  (defvar *input-1*
    (with-open-file (s "input/2018/1.txt")
      (loop for line = (read-line s nil :eof)
            until (eq line :eof)
            collect (parse-integer line))))
#+END_SRC
*** Part 1
The first problem is trivial given how I parsed the data. I just need
to sum the input.
#+NAME: problem-1a
#+BEGIN_SRC lisp
  (defun problem-1a ()
    (format t "Problem 1a: ~a~%" (reduce #'+ *input-1*)))
#+END_SRC
*** Part 2
This one was trickier, but mostly because I shouldn't code after
midnight. I used a hash table to track whether a frequency had ever
been seen. If the frequency has been seen before, return from the
outer loop. Otherwise, add the new frequency to the hash table.
#+NAME: find-first-duplicate
#+BEGIN_SRC lisp
  (defun find-first-duplicate (changes)
    (let ((tracker (make-hash-table))
          (frequency 0))
      (loop named outer
        do (loop for change in changes
                 when (gethash frequency tracker)
                   do (return-from outer frequency)
                 else
                   do (setf (gethash frequency tracker) t)
                 do (incf frequency change)))))
#+END_SRC

#+NAME: problem-1b
#+BEGIN_SRC lisp :noweb yes
  <<find-first-duplicate>>
  (defun problem-1b ()
    (format t "Problem 1b: ~a~%" (find-first-duplicate *input-1*)))
#+END_SRC
*** Putting it all together 
#+NAME: day1
#+BEGIN_SRC lisp :noweb no-export :results output :tangle day1.lisp :exports both
  <<day1-input>>
  <<problem-1a>>
  <<problem-1b>>
  (problem-1a)
  (problem-1b)
#+END_SRC
*** Answers
#+RESULTS: day1
: Problem 1a: 502
: Problem 1b: 71961
** TODO Day 2
*** Input
#+NAME: day2-input
#+BEGIN_SRC lisp
  (defvar *input-2*
    (with-open-file (s "input/2018/2.txt")
      (loop for line = (read-line s nil :eof)
            until (eq line :eof)
            collect line)))
#+END_SRC

*** Part 1
We need to count up the number of IDs which have one or more
characters precisely twice and thrice. Multiplying these two together
to generate our checksum.

I'll simplify this later.
#+NAME: count-2p
#+BEGIN_SRC lisp
  (defun count-2p (string)
    (let ((chars (make-hash-table)))
      (loop for c across string
            if (gethash c chars)
              do (incf (gethash c chars))
            else
              do (setf (gethash c chars) 1))
      (loop for c being the hash-keys of chars
            if (= (gethash c chars) 2)
              return t)))
#+END_SRC
#+NAME: count-3p
#+BEGIN_SRC lisp
  (defun count-3p (string)
    (let ((chars (make-hash-table)))
      (loop for c across string
            if (gethash c chars)
              do (incf (gethash c chars))
            else
              do (setf (gethash c chars) 1))
      (loop for c being the hash-keys of chars
            if (= (gethash c chars) 3)
              return t)))
#+END_SRC
#+NAME: checksum
#+BEGIN_SRC lisp
  (defun checksum (strings)
    (* (loop for s in strings
             count (count-2p s))
       (loop for s in strings
             count (count-3p s))))
#+END_SRC
#+NAME: problem-2a
#+BEGIN_SRC lisp :noweb yes
  <<count-2p>>
  <<count-3p>>
  <<checksum>>
  (defun problem-2a () (format t "Problem 2b: ~a~%" (checksum *input-2*)))
#+END_SRC

#+RESULTS: problem-2a
: PROBLEM-2A
*** Part 2
The follow up problem is to find the pair of strings which are
different by only one character. If I had levenstein distance
implemented that'd be handy. But I don't, so I'm going to cheat. Go
character by character on each pair of strings, kicking them out if
more than two differ.
#+NAME: problem-2b
#+BEGIN_SRC lisp
  (defun find-boxes (strings)
    (loop named outer
          for s1 in strings
          do (loop for s2 in strings
                   do (loop for c1 across s1
                            for c2 across s2
                            with diffs = 0
                            if (not (char= c1 c2))
                               do (incf diffs)
                            if (> diffs 1)
                              return nil
                            finally (if (= diffs 1) (return-from outer (list s1 s2)))))))
  (defun problem-2b () (format t "Problem 2b:~%~{~a~%~}~%" (find-boxes *input-2*)))
#+END_SRC
*** Putting it all together
#+NAME: day2
#+BEGIN_SRC lisp :results output :exports both :noweb yes
  <<day2-input>>
  <<problem-2a>>
  <<problem-2b>>
  (problem-2a)
  (problem-2b)
#+END_SRC
*** Answers
#+RESULTS: day2
: Problem 2b: 8892
: Problem 2b:
: zihwtxagsifpbsnwleydukjmqv
: zihwtxagwifpbsnwleydukjmqv
: 
I didn't *finish* part 2 in code, I just printed both strings and
examined them. Going to spend some time now cleaning these solutions
up, I'm not happy with either.
** TODO Day 3
** TODO Day 4
** TODO Day 5
** TODO Day 6
** TODO Day 7
** TODO Day 8
** TODO Day 9
** TODO Day 10
** TODO Day 11
** TODO Day 12
** TODO Day 13
** TODO Day 14
** TODO Day 15
** TODO Day 16
** TODO Day 17
** TODO Day 18
** TODO Day 19
** TODO Day 20
** TODO Day 21
** TODO Day 22
** TODO Day 23
** TODO Day 24
** TODO Day 25


