#+STARTUP: indent
#+OPTIONS: toc:nil num:nil
* Advent of Code 2018 [3/25]
This will be my attempt to solve the various Advent of Code 2018
problems with Common Lisp.
** DONE Day 1
[[https://adventofcode.com/2018/day/1][Problem Description]]
*** Input
The input for this one is a file with a number per line in the format
=(+|-)[0-9]+=. Common Lisp can read each line directly to a string. I
then had it parse each line into an integer directly.
#+NAME: day1-input
#+BEGIN_SRC lisp
  (defvar *input-1*
    (with-open-file (s "input/2018/1.txt")
      (loop for line = (read-line s nil :eof)
            until (eq line :eof)
            collect (parse-integer line))))
#+END_SRC
*** Part 1
The first problem is trivial given how I parsed the data. I just need
to sum the input.
#+NAME: problem-1a
#+BEGIN_SRC lisp
  (defun problem-1a ()
    (format t "Problem 1a: ~a~%" (reduce #'+ *input-1*)))
#+END_SRC
*** Part 2
This one was trickier, but mostly because I shouldn't code after
midnight. I used a hash table to track whether a frequency had ever
been seen. If the frequency has been seen before, return from the
outer loop. Otherwise, add the new frequency to the hash table.
#+NAME: find-first-duplicate
#+BEGIN_SRC lisp
  (defun find-first-duplicate (changes)
    (let ((tracker (make-hash-table))
          (frequency 0))
      (loop named outer
        do (loop for change in changes
                 when (gethash frequency tracker)
                   do (return-from outer frequency)
                 else
                   do (setf (gethash frequency tracker) t)
                 do (incf frequency change)))))
#+END_SRC

#+NAME: problem-1b
#+BEGIN_SRC lisp :noweb yes
  <<find-first-duplicate>>
  (defun problem-1b ()
    (format t "Problem 1b: ~a~%" (find-first-duplicate *input-1*)))
#+END_SRC
*** Putting it all together 
#+NAME: day1
#+BEGIN_SRC lisp :noweb no-export :results output :tangle day1.lisp :exports both
  <<day1-input>>
  <<problem-1a>>
  <<problem-1b>>
  (problem-1a)
  (problem-1b)
#+END_SRC
*** Answers
#+RESULTS: day1
: Problem 1a: 502
: Problem 1b: 71961
** DONE Day 2
*** Input
Today's input is a file with one string per line. Each line is an ID
of a box.
#+NAME: day2-input
#+BEGIN_SRC lisp
  (defvar *input-2*
    (with-open-file (s "input/2018/2.txt")
      (loop for line = (read-line s nil :eof)
            until (eq line :eof)
            collect line)))
#+END_SRC
*** Part 1
We need to count up the number of IDs which have one or more
characters precisely twice and thrice. Multiplying these two together
to generate our checksum.

The first thing I've done is generalize the original counting
functions, so now there's one that takes a parameter.
#+NAME: count-np
#+BEGIN_SRC lisp
  (defun count-np (string n)
    (let ((chars (make-hash-table)))
      (loop for c across string
            if (gethash c chars)
              do (incf (gethash c chars))
            else
              do (setf (gethash c chars) 1))
      (loop for c being the hash-keys of chars
            if (= (gethash c chars) n)
              return t)))
#+END_SRC
#+NAME: checksum
#+BEGIN_SRC lisp
  (defun checksum (strings)
    (* (loop for s in strings
             count (count-np s 2))
       (loop for s in strings
             count (count-np s 3))))
#+END_SRC
#+NAME: problem-2a
#+BEGIN_SRC lisp :noweb yes
  <<count-2p>>
  <<count-3p>>
  <<count-np>>
  <<checksum>>
  (defun problem-2a () (format t "Problem 2b: ~a~%" (checksum *input-2*)))
#+END_SRC
*** Part 2
The follow up problem is to find the pair of strings which are
different by only one character. Go character by character on each
pair of strings, kicking them out if more than two differ. If any pair
are found that differ by just 1, return that immediately.
#+NAME: problem-2b
#+BEGIN_SRC lisp
  (defun find-boxes (strings)
    (loop named outer
          for s1 in strings
          do (loop for s2 in strings
                   do (loop for c1 across s1
                            for c2 across s2
                            with diffs = 0
                            if (not (char= c1 c2))
                               do (incf diffs)
                            if (> diffs 1)
                              return nil
                            finally (if (= diffs 1) (return-from outer (list s1 s2)))))))
  (defun problem-2b () (format t "Problem 2b:~%~{~a~%~}~%" (find-boxes *input-2*)))
#+END_SRC
*** Putting it all together
#+NAME: day2
#+BEGIN_SRC lisp :results output :exports both :noweb yes
  <<day2-input>>
  <<problem-2a>>
  <<problem-2b>>
  (problem-2a)
  (problem-2b)
#+END_SRC
*** Answers
#+RESULTS: day2
: Problem 2b: 8892
: Problem 2b:
: zihwtxagsifpbsnwleydukjmqv
: zihwtxagwifpbsnwleydukjmqv
: 
I didn't *finish* part 2 in code, I just printed both strings and
examined them. Going to spend some time now cleaning these solutions
up, I'm not happy with either.
** DONE Day 3
*** Input
Each line of the input file had the format:
#+BEGIN_EXPORT ascii
  #ID @ LEFT,TOP : WIDTHxHEIGHT
#+END_EXPORT
I didn't want to parse that, so I had emacs transform that into a list
of the form:
#+BEGIN_EXPORT ascii
  ((id (left top) (witdth height) ...)
#+END_EXPORT
A single read of the input file is all that's needed to parse it
thanks to CL's reader.
#+NAME: day3-input
#+BEGIN_SRC lisp
  (defvar *input-3*
    (with-open-file (s "input/2018/3.txt")
      (read s)))
#+END_SRC
*** Part 1
We need to find out how many spaces have been claimed multiple
times. The maximum size is 1000x1000 based on evaluating the claims.
#+NAME: problem-3a
#+BEGIN_SRC lisp :noweb yes
  (defun overlapping-spaces (cuts)
    (let ((fabric (make-array '(1000 1000) :initial-element 0))
          (overlap 0))
      (loop for (id (left top) (width height)) in cuts
            do (loop for i from left below (+ left width)
                     do (loop for j from top below (+ top height)
                              do (incf (aref fabric i j)))))
      (loop for i from 0 below 1000
            do (loop for j from 0 below 1000
                     if (> (aref fabric i j) 1)
                       do (incf overlap)))
      overlap))
  (defun problem-3a () (format t "Problem 3a: ~a~%" (overlapping-spaces *input-3*)))
#+END_SRC
*** Part 2
So the logic above mostly works for what we need now. However, instead
of counting the claims we will mark each space with the various
claims, this'll just be a list. nil will represent unclaimed
spaces. At the end, we just need to find one claim which is fully its
own. To do that, we iterate over the space of each claim. If it has
any spaces which are shared, we skip it and go to the next one. If we
get to the very end of the cut and there's no overlap, we return that.
#+NAME: problem-3b
#+BEGIN_SRC lisp :noweb yes
  (defun unique-claim (cuts)
    (let ((fabric (make-array '(1000 1000) :initial-element nil))
          (unique nil))
      (loop for (id (left top) (width height)) in cuts
            do (loop for i from left below (+ left width)
                     do (loop for j from top below (+ top height)
                              do (setf (aref fabric i j) (cons id (aref fabric i j))))))
      (loop named outer
            for (id (left top) (width height)) in cuts
            do (loop named per-id
                     for i from left below (+ left width)
                     do (loop for j from top below (+ top height)
                              if (> (length (aref fabric i j)) 1)
                                do (return-from per-id nil)
                              if (and (= i (1- (+ left width)))
                                      (= j (1- (+ top height))))
                                do (return-from outer (aref fabric i j)))))))
  (defun problem-3b () (format t "Problem 3b: ~a~%" (unique-claim *input-3*)))
#+END_SRC
*** Putting it all together
#+NAME: day3
#+BEGIN_SRC lisp :results output :exports both :noweb yes
  <<day3-input>>
  <<problem-3a>>
  <<problem-3b>>
  (problem-3a)
  (problem-3b)
#+END_SRC
*** Answers
#+RESULTS: day3
: Problem 3a: 110546
: Problem 3b: (819)
** TODO Day 4
** TODO Day 5
** TODO Day 6
** TODO Day 7
** TODO Day 8
** TODO Day 9
** TODO Day 10
** TODO Day 11
** TODO Day 12
** TODO Day 13
** TODO Day 14
** TODO Day 15
** TODO Day 16
** TODO Day 17
** TODO Day 18
** TODO Day 19
** TODO Day 20
** TODO Day 21
** TODO Day 22
** TODO Day 23
** TODO Day 24
** TODO Day 25


