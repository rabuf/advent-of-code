#+STARTUP: indent
#+OPTIONS: toc:nil num:nil
* Advent of Code 2017
** Day 1
*** Input
The input is a sequence of numbers, all entered on one line. For ease
of solving this problem, it's best to interpret this as a string and
split it into a list of individual numbers.
#+NAME: day1-input
#+BEGIN_SRC lisp
  (defvar *input-2017-1*
    (with-open-file (s "input/1.txt")
      (let ((input (read-line s)))
        (loop for c across input
              collect (- (char-int c) 48)))))
#+END_SRC
*** Part 1
To solve this, I take the input and create a rotated version (first
digit becomes last).

Then compare each digit with its successor. If they match, keep that
value, otherwise, keep 0.
#+NAME: simple-captcha
#+BEGIN_SRC lisp
  (defun simple-captcha (digits)
    (let ((rotated (append (rest digits) (list (first digits)))))
      (reduce #'+  (mapcar (lambda (a b)
                             (if (= a b) a 0))
                           digits rotated))))
#+END_SRC
#+NAME: problem-1a
#+BEGIN_SRC lisp :noweb yes
  <<simple-captcha>>
  (defun problem-2017-1a ()
    (format t "Problem 1a: ~a~%" (simple-captcha *input-2017-1*)))
#+END_SRC
*** Part 2
For part 2, we need to split the digits into two halves rather than a
simple rotation.
#+NAME: complex-captcha
#+BEGIN_SRC lisp
  (defun complex-captcha (digits)
    (let* ((n (/ (length digits) 2))
           (front (reverse (nthcdr n (reverse digits))))
           (back (nthcdr n digits))
           (rotated (append back front)))
      (reduce #'+  (mapcar (lambda (a b)
                             (if (= a b) a 0))
                           digits rotated))))
#+END_SRC
#+NAME: problem-1b
#+BEGIN_SRC lisp :noweb yes
  <<complex-captcha>>
  (defun problem-2017-1b ()
    (format t "Problem 1b: ~a~%" (complex-captcha *input-2017-1*)))
#+END_SRC
*** Putting it all together
#+NAME: day1
#+BEGIN_SRC lisp :noweb no-export :results output :exports both
  <<day1-input>>
  <<problem-1a>>
  <<problem-1b>>
  (problem-2017-1a)
  (problem-2017-1b)
#+END_SRC
*** Answer
#+RESULTS: day1
: Problem 1a: 1144
: Problem 1b: 1194
** Day 2
*** Input
The input for this one is a sequence of lines each with a sequence of
numbers. Using two loops, I read each line and then read across the
line to collect its numbers. Treating the line as an input stream and
using the lisp reader.
#+NAME: day2-input
#+BEGIN_SRC lisp
  (defvar *input-2017-2*
    (with-open-file (s "input/2.txt")
      (loop for line = (read-line s nil :eof)
            until (eq line :eof)
            collect (with-input-from-string (l line)
                      (loop for num = (read l nil :eof)
                            until (eq num :eof)
                            collect num)))))
#+END_SRC
*** Part 1
This one was straightforward. For each row take the difference of the
min and max entries, then sum up the result from all rows.
#+NAME: simple-checksum
#+BEGIN_SRC lisp
  (defun simple-checksum (rows)
    (loop for row in rows
          sum (- (reduce #'max row) (reduce #'min row))))
#+END_SRC
#+NAME: problem-2a
#+BEGIN_SRC lisp :noweb yes
  <<simple-checksum>>
  (defun problem-2017-2a ()
     (format t "Problem 2a: ~a~%" (simple-checksum *input-2017-2*)))
#+END_SRC
*** Part 2
This one is more complex. On each row, find the pair of values that
evenly divide each other. I'm sure there's a simpler loop
construct. I'm basically constructing something akin to a division
table for each row, throwing out all values that aren't integers or
where the row and column are the same value. Then summing up the
results from all the rows.
#+NAME: complex-checksum
#+BEGIN_SRC lisp
  (defun complex-checksum (rows)
    (loop for row in rows
          sum (loop named outer
                    for r in row
                    do (loop for c in row
                             if (and (not (= r c)) (integerp (/ r c)))
                               do (return-from outer (/ r c))))))
#+END_SRC
#+NAME: problem-2a
#+BEGIN_SRC lisp :noweb yes
  <<complex-checksum>>
  (defun problem-2017-2b ()
     (format t "Problem 2b: ~a~%" (complex-checksum *input-2017-2*)))
#+END_SRC
*** Putting it all together
#+NAME: day2
#+BEGIN_SRC lisp :noweb yes :results output :exports both
  <<day2-input>>
  <<problem-2a>>
  <<problem-2b>>
  (problem-2017-2a)
  (problem-2017-2b)
#+END_SRC
*** Answer
#+RESULTS: day2
: Problem 2a: 45972
: Problem 2b: 326
** Day 3
*** Input
Today's input is a single number so no parsing.
#+NAME: day3-input
#+BEGIN_SRC lisp
  (defvar *input-2017-3* 347991)
#+END_SRC
*** Data Structures
#+NAME: point
#+BEGIN_SRC lisp
  (defstruct (point
              (:conc-name pt-))
    x
    y)
#+END_SRC
*** Part 1
This is an interesting problem. So the memory grows in a spiral. I
have to determine the Cartesian coordinates for the memory cell
identified by the input number, and then calculate it's distance to 1
(the origin).
#+NAME: manhattan-distance
#+BEGIN_SRC lisp
  (defun manhattan-distance (p1 p2)
    (destructuring-bind ((x1 y1) (x2 y2)) (list p1 p2)
      (+ (abs (- x1 x2)) (abs (- y1 y2)))))
#+END_SRC

#+RESULTS: manhattan-distance
: MANHATTAN-DISTANCE

Now we have to convert the input into a position. It's helpful to note
that all *odd* perfect squares occur on a diagonal moving
down-and-right from 1. All *even* perfect squares occur on a diagonal
moving up-and-left from 4. If we know which two perfect squares are
nearest the input then we can identify it's precise location by moving
along the path from (lower square) to (upper square).

Doing this one manually right now, we have:
- lower :: 346921
- upper :: 348100

When examining the squares, the square for the nth odd number
(starting at 1) is located at (n-1,-(n-1)). So 1 is at (0,0). 9 is the
square of 3 (the 2nd odd number) is located at (1,-1), etc.

A similar pattern exists for the squares of even numbers: (-n+1,n).

So we need to determine the locations of *lower* and *upper*.

*lower* is the square of the 294th odd number, and *upper* is the
square of the 295th even number. So that puts our solution along the
path from (294,-294) to (-294,295).

Alright, so I can now convert *squares* to positions. And I can
determine the distance between them. We also know how far from each
our input is. In this case, we're only 109 from *upper*. That's over
half the total distance between *upper* and *lower*, so we can find
our position by moving horizontally right from *upper*.

(-185,295)

The manhattan distance is 480.

*** Part 2
*** Putting it all together
#+NAME: day3
*** Answer
