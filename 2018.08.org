#+STARTUP: indent content
#+OPTIONS: num:nil toc:nil
* Day 8
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2018-08)=
4. Typing =C-c C-c= in the block [[answers][answers]].
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2018-08
    (:use :common-lisp
          :iterate)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-08)
#+END_SRC
** Input
Using the stream to help with parsing. I was really trying to do this
a different way (read the whole file into a list and then convert that
into a tree). But I kept getting tripped up. Ultimately, I was able to
gather the metadata doing that but I couldn't quite restore the tree
structure itself.

The code got really ugly, so this version is better. The code I had
was recursive like this, but had multiple value returns: the newly
constructed child node and a list with all the data used in
constructing that node removed. It wasn't very readable, and it was a
bear to try to debug.
#+NAME: node
#+BEGIN_SRC lisp :results silent
  (defstruct node
    (children nil)
    (metadata nil))
#+END_SRC

#+NAME: make-tree
#+BEGIN_SRC lisp :results silent
  (defun make-tree (stream)
    (let* ((child-count (read stream))
           (metadata-count (read stream))
           (children (iter (repeat child-count)
                           (collect (make-tree stream))))
           (metadata (iter (repeat metadata-count)
                           (collect (read stream)))))
      (make-node :children children :metadata metadata)))
#+END_SRC

The problem I ran into is illustrated here:
#+BEGIN_SRC lisp :results output export
  (defun do-something (list)
    (format t "~a~%" list)
    (pop list)
    (format t "~a~%" list))
  (let ((list (list 1 2 3)))
    (format t "~a~%" list)
    (do-something list)
    (format t "~a~%" list))
#+END_SRC

#+RESULTS:
: (1 2 3)
: (1 2 3)
: (2 3)
: (1 2 3)
So I originally had a recursive call like:
#+BEGIN_SRC lisp :results silent
  (defun make-tree-flawed (list)
    (let* ((child-count (pop list))
           (metadata-count (pop list))
           (children (iter (repeat child-count)
                           (collect (make-tree-flawed list))))
           (metadata (iter (repeat metadata-count)
                           (collect (pop list)))))
      (make-node :children children :metadata metadata)))
#+END_SRC
(NB: The original was more complicated, but amounted to the same logic).

The output of the above is garbage.

To have the effect I wanted, I needed the same list variable to be in
the scope of all the recursive calls. This required a local recursive
function:
#+BEGIN_SRC lisp :results silent
  (defun make-tree-list (list)
    (labels ((recurse ()
               (let* ((child-count (pop list))
                      (metadata-count (pop list))
                      (children (iter (repeat child-count)
                                      (collect (recurse))))
                      (metadata (iter (repeat metadata-count)
                                      (collect (pop list)))))
                 (make-node :children children :metadata metadata))))
      (recurse)))
#+END_SRC

Now that recursive version, converting lists to trees, works just
fine. Though I'm not using it.

#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (with-open-file (s file)
      (make-tree s)))
#+END_SRC

#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  <<read-input>>
  (defparameter *input*
    (read-input "input/8.txt"))
#+END_SRC
** Part 1
Part 1 wants the sum of the metadata of each node. This is a
straightforward recursive solution.
#+NAME: sum-tree
#+BEGIN_SRC lisp :results silent
  (defun sum-tree (node)
    (+ (iter (for c in (node-children node))
             (sum (sum-tree c)))
       (reduce #'+ (node-metadata node))))
#+END_SRC
#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 8a: ~a~%" (sum-tree *input*)))
#+END_SRC
** Part 2
Node value is defined as either:

If the node has no children, the sum of its metadata.

If the node has children, the sum of the nodes referenced by the
metadata. If the metadata refers to a non-existent node, its value is
considered 0.

Another recursive solution. The only other complexity is that the
input assumes sequence access starts at 1, while lisp uses 0 as the
first element. So we have to decrement 1 from the metadata values to
get the index.
#+NAME: node-value
#+BEGIN_SRC lisp :results noen
  (defun node-value (node)
    (let ((children (node-children node))
          (metadata (node-metadata node)))
      (cond ((null children) (reduce #'+ metadata))
            (t (iter (for m in metadata)
                     (unless (or (= 0 m) (> m (length children)))
                       (sum (node-value (elt children (1- m))))))))))
#+END_SRC

#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes
    (defun problem-b () (format t "Problem 8b: ~a~%" (node-value *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes
  <<node>>
#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<list-to-metadata-list>>
  <<make-tree>>
  <<node-value>>
  <<sum-tree>>
#+END_SRC

#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.08.lisp
  <<structs>>
  <<input>>
  <<functions>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
: Problem 8a: 37439
: Problem 8b: 20815

** Thoughts
