#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 13
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2018-13)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2018-13
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-13)
#+END_SRC
** Input
Well, this is going to be an interesting nut to crack. The elves are
still poor planners. They've devised an incredibly complex
track-and-cart system. IT's described in an ASCII art format:

A simple closed loop:
#+BEGIN_EXAMPLE
  /----\
  |    |
  |    |
  \----/
#+END_EXAMPLE

Two loops with intersections.
#+BEGIN_EXAMPLE
  /-----\
  |     |
  |  /--+--\
  |  |  |  |
  \--+--/  |
     |     |
     \-----/
#+END_EXAMPLE

Also in the input are carts whose positions are given as <, >, v, or ^
(the arrow pointing in their direction of movement).

I really don't know where to start on this particular problem. I
suppose a grid represening the tracks and a vector or list of the
carts and their positions and headings.

I initially stored everything from the map in one big array. I've
stopped doing that, it's silly. The only positions on the map that
actually matter are the curves and the intersections. I've put those
into a hash table.

For the hash table of curves and intersections, I'm storing a function
to handle the particular kind of turn.

For =/=, whether the cart is moving up or down it will "turn
right". That is, it's initial heading will be either =(1,0)= or
=(-1,0)= and its next heading will be =(0,-1)= or =(0,1)=,
respectively. If it's going horizontally, it will turn left. I call
this a "right-curve" because of the upward-and-right direction of the
=/=.

For =\= the result is the opposite. I call this the "left-curve".
#+NAME: turning-and-intersection-handling
#+BEGIN_SRC lisp :results silent
  (defun turn (cart direction)
    (list (first cart)
          (* (second cart) direction)
          (third cart)))
  (defun turn-right (cart)
    (turn cart #C(0 1)))
  (defun turn-left (cart)
    (turn cart #C(0 -1)))
  (defun left-curve (cart)
    (if (= (imagpart (second cart)) 0)
        (turn-right cart)
        (turn-left cart)))
  (defun right-curve (cart) ;;/
    (if (= (imagpart (second cart)) 0)
        (turn-left cart)
        (turn-right cart)))
  (defun inter (cart)
    (destructuring-bind (position heading next-turn)
        cart
      (case next-turn
        (:left (turn-left (list position heading :straight)))
        (:straight (list position heading :right))
        (:right (turn-right (list position heading :left))))))
#+END_SRC

#+NAME: parse-input
#+BEGIN_SRC lisp :results silent
  (defun cart-direction (c)
    (case c
      (#\< #C(-1 0))
      (#\> #C(1 0))
      (#\v #C(0 1))
      (#\^ #C(0 -1))))
  (defun is-cart (c)
    (member c '(#\< #\> #\v #\^)))


  (defun parse-input (lines)
    (let* ((grid (make-hash-table))
           (carts nil))
      (iter (for y from 0)
            (for line in lines)
            (iter (for x from 0)
                  (for c in-string line)
                  (unless (is-cart c)
                    (case c
                      (#\\ (setf (gethash (complex x y) grid) 'left-curve))
                      (#\/ (setf (gethash (complex x y) grid) 'right-curve))
                      (#\+ (setf (gethash (complex x y) grid) 'inter))
                      (otherwise nil)))
                  (when (is-cart c)
                    (push (list (complex x y) (cart-direction c) :left) carts))))
      (list grid carts)))
#+END_SRC
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (parse-input (read-input "input/13.txt")))
#+END_SRC
** Part 1
Part 1 asks for the coordinates of the first collision between carts.

Carts move 1 at a time starting at the top left, moving left to right
and top to bottom. A time tick occurs after every cart has moved.

When a cart encounters an intersection it cycles through: left,
stragiht, right, repeat.

This means a cart's state consists of: position, heading, turn-state.

At the start of each tick, I need to sort all the carts.
#+NAME: sort-carts
#+BEGIN_SRC lisp :results silent
  (defun sort-carts (carts)
    (sort carts (lambda (p1 p2)
                  (or (< (imagpart p1) (imagpart p2))
                      (and (= (imagpart p1) (imagpart p2))
                           (< (realpart p1) (realpart p2)))
                      (= p1 p2)))
          :key #'first))
#+END_SRC

Alright, so that works. Now I need to do a tick, where I update every
cart position.

#+NAME: tick
#+BEGIN_SRC lisp :results silent
  ;; Below is a simple test, using the first element as the key, no
  ;; carts should be removed by this test.
  (defun has-collision (carts)
    (not (= (length carts)
            (length (remove-duplicates carts :key #'first)))))

  (defun move-cart (grid cart)
    (destructuring-bind (position heading next-turn) cart
      (incf position heading)
      (if (gethash position grid)
          (funcall (gethash position grid) (list position heading next-turn))
          (list position heading next-turn))))

  (defun tick (grid carts)
    (let ((sorted (sort-carts (copy-seq carts))))
      (iter (for cart in sorted)
            (for i from 0)
            (setf (elt sorted i) (move-cart grid cart))
            (when (has-collision sorted)
              (format t "Collision at ~A~%" (first (elt sorted i)))
              (return nil))
            (finally (return sorted)))))
#+END_SRC

#+NAME: solve-a
#+BEGIN_SRC lisp :results silent
  (defun solve-a (scenario &optional (limit 1000))
    (let ((grid (car scenario))
          (carts (cadr scenario)))
      (when *debug*
        (format t "~A~%" carts))
      (iter (for i from 0 to limit)
            (setf carts (tick grid carts))
            (when *debug*
              (format t "~A~%" carts))
            (unless carts
              (return i)))))
#+END_SRC

#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 13 A: ~a~%" (solve-a *input*)))
#+END_SRC
** Part 2
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b () (format t "Problem 13 B: ~a~%" (identity *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<turning-and-intersection-handling>>
  <<parse-input>>
  <<read-input>>
  <<sort-carts>>
  <<tick>>
  <<solve-a>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.13.lisp
  (defparameter *debug* nil)
  <<structs>>
  <<initialize>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
#+begin_example
Collision at #C(83 121)
Problem 13 A: 241
Problem 13 B: (#<HASH-TABLE :TEST EQL :COUNT 4250 {1002B9F483}>
               ((#C(9 143) 1 LEFT) (#C(125 139) #C(0 -1) LEFT)
                (#C(67 134) -1 LEFT) (#C(117 132) #C(0 1) LEFT)
                (#C(69 130) -1 LEFT) (#C(134 121) -1 LEFT) (#C(44 84) -1 LEFT)
                (#C(97 81) -1 LEFT) (#C(138 80) #C(0 1) LEFT)
                (#C(87 55) #C(0 -1) LEFT) (#C(66 51) #C(0 1) LEFT)
                (#C(137 49) #C(0 1) LEFT) (#C(120 29) 1 LEFT)
                (#C(31 24) -1 LEFT) (#C(144 19) #C(0 1) LEFT)
                (#C(29 11) #C(0 1) LEFT) (#C(67 9) 1 LEFT)))
#+end_example
** Test Cases
#+BEGIN_EXAMPLE
/->-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   
#+END_EXAMPLE

Above is a simple test case, it's result is =7,3=.

#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  ;; For some reason 
  (let ((test-case 
         `("/->-\\        "
           "|   |  /----\\"
           "| /-+--+-\\  |"
           "| | |  | v  |"
           "\\-+-/  \\-+--/"
           "  \\------/   "))
        (*debug* nil))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" (solve-a (parse-input test-case) 20)))

  ;; This test case is good, they collide at (2,1)
  (let* ((test-case 
          `("     " ">--<"))
         (scenario (parse-input test-case))
         (grid (first scenario))
         (carts (second scenario)))
    (iter (for (k v) in-hashtable grid)
          (format t "~a~%" (list k v)))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" carts)
    (setf carts (tick grid carts))
    (format t "~A~%" carts)
    (setf carts (tick grid carts))
    (format t "~A~%" carts))

  ;; This test case is good, they collide at (1,2)
  (let* ((test-case 
          `("   "
            " v "
            " v "))
         (scenario (parse-input test-case))
         (grid (first scenario))
         (carts (second scenario)))
    (iter (for (k v) in-hashtable grid)
          (format t "~a~%" (list k v)))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" carts)
    (setf carts (sort-carts carts))
    (format t "~A~%" carts)
    (setf carts (tick grid carts))
    (format t "~A~%" carts)
    (setf carts (tick grid carts))
    (format t "~A~%" carts))

  ;; So solve works on this particular case.
  (let* ((test-case 
          `("   "
            " v "
            " v "))
         (scenario (parse-input test-case)))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" (solve-a scenario)))

  ;; Let's have a simple curve. Turning isn't working correctly.
  (let* ((test-case 
          `("   "
            " v "
            " \\--< "))
         (*debug* t)
         (scenario (parse-input test-case)))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" (solve-a scenario 10)))
#+END_SRC
** Test Results
#+RESULTS: test-cases
#+begin_example
/->-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   
Collision at #C(7 3)
13
     
>--<
((#C(3 1) -1 LEFT) (#C(0 1) 1 LEFT))
((#C(1 1) 1 LEFT) (#C(2 1) -1 LEFT))
Collision at #C(2 1)
NIL
   
 v 
 v 
((#C(1 2) #C(0 1) LEFT) (#C(1 1) #C(0 1) LEFT))
((#C(1 1) #C(0 1) LEFT) (#C(1 2) #C(0 1) LEFT))
Collision at #C(1 2)
NIL
NIL
   
 v 
 v 
Collision at #C(1 2)
0
   
 v 
 \--< 
((#C(4 2) -1 LEFT) (#C(1 1) #C(0 1) LEFT))
((#C(1 2) 1 LEFT) (#C(3 2) -1 LEFT))
Collision at #C(2 2)
NIL
1
#+end_example
** Thoughts
