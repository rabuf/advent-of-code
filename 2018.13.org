#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 13
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2018-13)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2018-13
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-13)
#+END_SRC
** Input
Well, this is going to be an interesting nut to crack. The elves are
still poor planners. They've devised an incredibly complex
track-and-cart system. IT's described in an ASCII art format:

A simple closed loop:
#+BEGIN_EXAMPLE
  /----\
  |    |
  |    |
  \----/
#+END_EXAMPLE

Two loops with intersections.
#+BEGIN_EXAMPLE
  /-----\
  |     |
  |  /--+--\
  |  |  |  |
  \--+--/  |
     |     |
     \-----/
#+END_EXAMPLE

Also in the input are carts whose positions are given as <, >, v, or ^
(the arrow pointing in their direction of movement).

I really don't know where to start on this particular problem. I
suppose a grid represening the tracks and a vector or list of the
carts and their positions and headings.

I initially stored everything from the map in one big array. I've
stopped doing that, it's silly. The only positions on the map that
actually matter are the curves and the intersections. I've put those
into a hash table.

For the hash table of curves and intersections, I'm storing a function
to handle the particular kind of turn.

For =/=, whether the cart is moving up or down it will "turn
right". That is, its initial heading will be either =(1,0)= or
=(-1,0)= and its next heading will be =(0,-1)= or =(0,1)=,
respectively. If it's going horizontally, it will turn left. I call
this a "right-curve" because of the upward-and-right direction of the
=/=.

For =\= the result is the opposite. I call this the "left-curve".
#+NAME: turning-and-intersection-handling
#+BEGIN_SRC lisp :results silent
  (defun turn (cart direction)
    (list (first cart)
          (* (second cart) direction)
          (third cart)))
  (defun turn-right (cart)
    (turn cart #C(0 1)))
  (defun turn-left (cart)
    (turn cart #C(0 -1)))
  (defun left-curve (cart)
    (if (= (imagpart (second cart)) 0)
        (turn-right cart)
        (turn-left cart)))
  (defun right-curve (cart) ;;/
    (if (= (imagpart (second cart)) 0)
        (turn-left cart)
        (turn-right cart)))
  (defun inter (cart)
    (destructuring-bind (position heading next-turn)
        cart
      (case next-turn
        (:left (turn-left (list position heading :straight)))
        (:straight (list position heading :right))
        (:right (turn-right (list position heading :left))))))
#+END_SRC

#+NAME: parse-input
#+BEGIN_SRC lisp :results silent
  (defun cart-direction (c)
    (case c
      (#\< #C(-1 0))
      (#\> #C(1 0))
      (#\v #C(0 1))
      (#\^ #C(0 -1))))
  (defun is-cart (c)
    (member c '(#\< #\> #\v #\^)))


  (defun parse-input (lines)
    (let* ((grid (make-hash-table))
           (carts nil))
      (iter (for y from 0)
            (for line in lines)
            (iter (for x from 0)
                  (for c in-string line)
                  (unless (is-cart c)
                    (case c
                      (#\\ (setf (gethash (complex x y) grid) 'left-curve))
                      (#\/ (setf (gethash (complex x y) grid) 'right-curve))
                      (#\+ (setf (gethash (complex x y) grid) 'inter))
                      (otherwise nil)))
                  (when (is-cart c)
                    (push (list (complex x y) (cart-direction c) :left) carts))))
      (list grid carts)))
#+END_SRC
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (parse-input (read-input "input/13.txt")))
#+END_SRC
** Part 1
Part 1 asks for the coordinates of the first collision between carts.

Carts move 1 at a time starting at the top left, moving left to right
and top to bottom. A time tick occurs after every cart has moved.

When a cart encounters an intersection it cycles through: left,
stragiht, right, repeat.

This means a cart's state consists of: position, heading, turn-state.

At the start of each tick, I need to sort all the carts.
#+NAME: sort-carts
#+BEGIN_SRC lisp :results silent
  (defun sort-carts (carts)
    (sort carts (lambda (p1 p2)
                  (or (< (imagpart p1) (imagpart p2))
                      (and (= (imagpart p1) (imagpart p2))
                           (< (realpart p1) (realpart p2)))
                      (= p1 p2)))
          :key #'first))
#+END_SRC

Alright, so that works. Now I need to do a tick, where I update every
cart position.

#+NAME: tick
#+BEGIN_SRC lisp :results silent
  ;; Below is a simple test, using the first element as the key, no
  ;; carts should be removed by this test.
  (defun has-collision (carts)
    (not (= (length carts)
            (length (remove-duplicates carts :key #'first)))))

  (defun move-cart (grid cart)
    (destructuring-bind (position heading next-turn) cart
      (incf position heading)
      (if (gethash position grid)
          (funcall (gethash position grid) (list position heading next-turn))
          (list position heading next-turn))))

  (defun tick (grid carts)
    (let ((sorted (sort-carts (copy-seq carts)))
          (result nil))
      (iter (until (null sorted))
            (let ((cart (move-cart grid (pop sorted))))
              (cond ((or (has-collision (cons cart result))
                         (has-collision (cons cart sorted)))
                     (format t "Collision at ~A~%" (first cart))
                     (setf result (remove (car cart) result :key #'first))
                     (setf sorted (remove (car cart) sorted :key #'first)))
                    (t (push cart result)))))
      result))
#+END_SRC

#+NAME: solve-a
#+BEGIN_SRC lisp :results silent
  (defun solve-a (scenario &optional (limit 1000))
    (let ((grid (car scenario))
          (carts (cadr scenario)))
      (when *debug*
        (format t "~A~%" carts))
      (iter (for i from 0 to limit)
            (setf carts (tick grid carts))
            (when *debug*
              (format t "~A~%" carts))
            (when (= 1 (length carts))
              (return carts))
            (when (null carts)
              (return nil)))))
#+END_SRC

#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 13 A: ~a~%" (solve-a *input* 100000)))
#+END_SRC
** Part 2
Now we need to know at what point the last cart will be located. I'm
going to just modify the above code and change some things
below. Since I'm already printing out each collision, I'll change my
=tick= function to remove all collisions and return the remaining
carts. When there's just one left, =solve-a= will return it.
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b () (format t "Problem 13 B: ~a~%" (identity *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<turning-and-intersection-handling>>
  <<parse-input>>
  <<read-input>>
  <<sort-carts>>
  <<tick>>
  <<solve-a>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.13.lisp
  (defparameter *debug* nil)
  <<structs>>
  <<initialize>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (format t "How many carts? ~A~%" (length (second *input*)))
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
#+begin_example
How many carts? 17
Collision at #C(83 121)
Collision at #C(115 104)
Collision at #C(8 57)
Collision at #C(64 109)
Collision at #C(101 22)
Collision at #C(49 106)
Collision at #C(136 87)
Collision at #C(108 89)
Problem 13 A: ((#C(102 144) -1 STRAIGHT))
Problem 13 B: (#<HASH-TABLE :TEST EQL :COUNT 4250 {100227E9D3}>
               ((#C(9 143) 1 LEFT) (#C(125 139) #C(0 -1) LEFT)
                (#C(67 134) -1 LEFT) (#C(117 132) #C(0 1) LEFT)
                (#C(69 130) -1 LEFT) (#C(134 121) -1 LEFT) (#C(44 84) -1 LEFT)
                (#C(97 81) -1 LEFT) (#C(138 80) #C(0 1) LEFT)
                (#C(87 55) #C(0 -1) LEFT) (#C(66 51) #C(0 1) LEFT)
                (#C(137 49) #C(0 1) LEFT) (#C(120 29) 1 LEFT)
                (#C(31 24) -1 LEFT) (#C(144 19) #C(0 1) LEFT)
                (#C(29 11) #C(0 1) LEFT) (#C(67 9) 1 LEFT)))
#+end_example
** Test Cases
#+BEGIN_EXAMPLE
/->-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   
#+END_EXAMPLE

Above is a simple test case, its result is =7,3=.

#+BEGIN_EXAMPLE
/>-<\  
|   |  
| /<+-\
| | | v
\>+</ |
  |   ^
  \<->/
#+END_EXAMPLE

The above is the test case for Part 2, its result is =6,4=
#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  (let ((test-case 
         `("/->-\\        "
           "|   |  /----\\"
           "| /-+--+-\\  |"
           "| | |  | v  |"
           "\\-+-/  \\-+--/"
           "  \\------/   "))
        (*debug* nil))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" (solve-a (parse-input test-case) 20)))
  (let ((test-case 
         '("/>-<\\  "
           "|   |  "
           "| /<+-\\"
           "| | | v"
           "\\>+</ |"
           "  |   ^"
           "  \\<->/")))
    (format t "~{~A~%~}" test-case)
    (format t "~A~%" (solve-a (parse-input test-case) 20)))

#+END_SRC
** Test Results
#+RESULTS: test-cases
#+begin_example
/->-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   
Collision at #C(7 3)
NIL
/>-<\  
|   |  
| /<+-\
| | | v
\>+</ |
  |   ^
  \<->/
Collision at 2
Collision at #C(2 4)
Collision at #C(6 4)
Collision at #C(2 4)
((#C(6 4) #C(0 -1) LEFT))
#+end_example
** Thoughts
