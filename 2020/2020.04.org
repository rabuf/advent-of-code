#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 04
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2020-04)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
  (unless (find-package :series)
    (ql:quickload "series"))
  (unless (find-package :cl-permutation)
    (ql:quickload "cl-permutation"))
  (unless (find-package :bordeaux-threads)
    (ql:quickload "bordeaux-threads"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2020-04
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2020-04)
#+END_SRC
** Input
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun gather-fields (lines)
    (loop for l in lines
       with result = nil
       with entry = ""
       do (cond ((string= "" l)
                 (push entry result)
                 (setf entry ""))
                (t (setf entry (concatenate 'string entry " " l))))
       finally (push entry result)
         (return result)))
  (defun read-input (file)
    (gather-fields
     (iter (for line in-file file using #'read-line)
           (collect line))))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (read-input "input/04.txt"))
#+END_SRC
** Part 1
#+NAME: validate-passport
#+BEGIN_SRC lisp :tangle no
  (defun validate-passport (passport)
    (let ((needed '("byr" "hgt" "iyr" "eyr" "hcl" "ecl" "pid")))
      (every (lambda (field) (cl-ppcre:scan field passport)) needed)))
#+END_SRC
#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  <<validate-passport>>
  (defun problem-a () (format t "Problem 04 A: ~a~%" (count-if #'validate-passport *input*)))
#+END_SRC
** Part 2
I *could* spend some time and fix up my parser to split out each
part. But I won't. I'll split it using =cl-ppcre= on spaces, then scan
each one and add a validator for each field prefix.
#+NAME: properly-validate
#+BEGIN_SRC lisp :results silent
  (defun get-field (field entry)
    (assoc field entry :test #'string=))
  (defun validate-byr (field)
    (and field
         (cl-ppcre:scan "[0-9]{4}" (second field))
         (<= 1920 (parse-integer (second field)) 2002)))
  (defun validate-iyr (field)
    (and field
         (cl-ppcre:scan "[0-9]{4}" (second field))
         (<= 2010 (parse-integer (second field)) 2020)))
  (defun validate-eyr (field)
    (and field
         (cl-ppcre:scan "[0-9]{4}" (second field))
         (<= 2020 (parse-integer (second field)) 2030)))
  (defun validate-hgt (field)
    (and field
         (let ((s (second field)))
           (or (and (string= "cm" (subseq s (- (length s) 2)))
                    (<= 150 (parse-integer s :junk-allowed t) 193))
               (and (string= "in" (subseq s (- (length s) 2)))
                    (<= 59 (parse-integer s :junk-allowed t) 76))))))
  (defun validate-hcl (field)
    (and field
         (cl-ppcre:scan "#[0-9a-f]{6}" (second field))))
  (defun validate-ecl (field)
    (and field
         (some (lambda (c) (string= c (second field)))
               '("amb" "blu" "brn" "gry" "grn" "hzl" "oth"))))
  (defun validate-pid (field)
    (and field
         (cl-ppcre:scan "^[0-9]{9}$" (second field))))
  (defun properly-validate (entry)
    (let ((fields (mapcar (lambda (e) (cl-ppcre:split ":" e))
                          (rest (cl-ppcre:split " " entry)))))
      (and (<= 7 (length fields) 8)
           (validate-byr (get-field "byr" fields))
           (validate-iyr (get-field "iyr" fields))
           (validate-eyr (get-field "eyr" fields))
           (validate-hgt (get-field "hgt" fields))
           (validate-hcl (get-field "hcl" fields))
           (validate-ecl (get-field "ecl" fields))
           (validate-pid (get-field "pid" fields)))))
#+END_SRC
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  <<properly-validate>>
  (defun problem-b () (format t "Problem 04 B: ~a~%" (count-if #'properly-validate *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<read-input>>
  <<input>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle no
  <<initialize>>
  <<structs>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
** Test Cases
#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  (def-suite aoc.2020.04)
  (in-suite aoc.2020.04)

  (run! 'aoc.2020.04)
#+END_SRC
** Test Results
#+RESULTS: test-cases
** Thoughts
** Ada
Simple runner.
#+BEGIN_SRC ada :tangle ada/day04.adb
  with AOC2020.Day04;
  procedure Day04 is
  begin
    null;
  end Day04;
#+END_SRC
Specification for solution.
#+BEGIN_SRC ada :tangle ada/aoc2020-day04.ads
  package AOC2020.Day04 is
     function Solve_01 return Integer;
     function Solve_02 return Integer;
  end AOC2020.Day04;
#+END_SRC
Actual implementation body.
#+BEGIN_SRC ada :tangle ada/aoc2020-day04.adb
  with GNAT.Regpat; use GNAT.Regpat;
  with Text_IO; use Text_IO;
  package body AOC2020.Day04 is
     -- Used as an example of matching regular expressions
     procedure Parse_Line (Line : Unbounded_String; P : out Password) is
        Pattern : constant String := "(\d+)-(\d+) ([a-z]): ([a-z]+)";
        Re : constant Pattern_Matcher := Compile(Pattern);
        Matches : Match_Array (0..4);
        Pass : Unbounded_String;
        P0, P1 : Positive;
        C : Character;
     begin
        Match(Re, To_String(Line), Matches);
        P0 := Integer'Value(Slice(Line, Matches(1).First, Matches(1).Last));
        P1 := Integer'Value(Slice(Line, Matches(2).First, Matches(2).Last));
        C := Element(Line, Matches(3).First);
        Pass := To_Unbounded_String(Slice(Line, Matches(4).First, Matches(4).Last));
        P := (Min_Or_Pos => P0,
              Max_Or_Pos => P1,
              C => C,
              P => Pass);
     end Parse_Line;
  begin
     null;
  end AOC2020.Day04;
#+END_SRC

In order to run this you have to "tangle" the code first using =C-c
C-v C-t=.

#+BEGIN_SRC shell :tangle no :results output :exports both
  cd ada
  gnatmake day04
  ./day04
#+END_SRC

#+RESULTS:
