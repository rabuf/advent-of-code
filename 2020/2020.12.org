#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 12
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2020-12)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
  (unless (find-package :series)
    (ql:quickload "series"))
  (unless (find-package :cl-permutation)
    (ql:quickload "cl-permutation"))
  (unless (find-package :bordeaux-threads)
    (ql:quickload "bordeaux-threads"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2020-12
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2020-12)
#+END_SRC
** Input
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (read-input "input/12.txt"))
#+END_SRC
** Part 1
Calculate the Manhattan distance from the starting point to where we
end up after following series of directions. Only L and R directions
cause us to rotate.
#+NAME: follow-directions
#+BEGIN_SRC lisp :results silent
  (defun turn-right (degrees)
    (ecase degrees
      (0 1)
      (90 #C(0 -1))
      (180 -1)
      (270 #C(0 1))))
  (defun turn-left (degrees)
    (ecase degrees
      (0 1)
      (90 #C(0 1))
      (180 -1)
      (270 #C(0 -1))))
  
  (defun follow-directions (directions)
    (loop for l in directions
       with pos = #C(0 0)
       with dir = #C(1 0)
       for command = (char l 0)
       for distance = (parse-integer (subseq l 1))
       finally (return (+ (abs (realpart pos)) (abs (imagpart pos))))
       do (case command 
            (#\F (incf pos (* distance dir)))
            (#\R (setf dir (* (turn-right distance) dir)))
            (#\L (setf dir (* (turn-left distance) dir)))
            (#\N (incf pos (* distance #C(0 1))))
            (#\S (incf pos (* distance #C(0 -1))))
            (#\E (incf pos (* distance #C(1 0))))
            (#\W (incf pos (* distance #C(-1 0)))))))
#+END_SRC
#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 12 A: ~a~%" (follow-directions *input*)))
#+END_SRC
** Part 2
Slightly more complicated for this part. The N/S/E/W/L/R all move the
waypoint. F now moves the ship *to* the waypoint a number of
times. The waypoint itself is always kept a constant position away
from the ship.

I'm going to continue using complex numbers because this makes it
easy. Fundamentally, N/S/E/W don't change except that instead of
changing pos, the waypoint is altered.

L and R, however, are different. It's now rotating *around* the
ship. Which is not too bad. Instead of adjusting a degrees we subtract
ship from waypoint, to place it at the origin, multiply like before,
then add the ship position back to restore it.

A thought, the waypoint can be maintained as simply a vector from the
origin. It's *always* relative to the ship, so we can simplify
rotation and skipping having to adjust it after moving the ship.
#+NAME: follow-waypoint
#+BEGIN_SRC lisp :results silent
  (defun turn-right (degrees)
    (ecase degrees
      (0 1)
      (90 #C(0 -1))
      (180 -1)
      (270 #C(0 1))))
  (defun turn-left (degrees)
    (ecase degrees
      (0 1)
      (90 #C(0 1))
      (180 -1)
      (270 #C(0 -1))))

  (defun follow-waypoint (directions)
    (loop for l in directions
       with pos = #C(0 0)
       with waypoint = #C(10 1)
       for command = (char l 0)
       for distance = (parse-integer (subseq l 1))
       finally (return (+ (abs (realpart pos)) (abs (imagpart pos))))
       do (case command 
            (#\F (incf pos (* distance waypoint)))
            (#\R (setf waypoint (* (turn-right distance) waypoint)))
            (#\L (setf waypoint (* (turn-left distance) waypoint)))
            (#\N (incf waypoint (* distance #C(0 1))))
            (#\S (incf waypoint (* distance #C(0 -1))))
            (#\E (incf waypoint (* distance #C(1 0))))
            (#\W (incf waypoint (* distance #C(-1 0)))))))
#+END_SRC
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b () (format t "Problem 12 B: ~a~%" (follow-waypoint *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<read-input>>
  <<input>>
  <<follow-directions>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle no
  <<initialize>>
  <<structs>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
#+begin_example
Problem 12 A: 362
Problem 12 B: (F93 R90 F81 E3 F80 R90 W4 R90 F64 N1 R90 W4 F11 W1 L180 F28 R90
               W4 L180 F95 N3 F71 L90 W1 F1 E2 L90 F85 W3 L90 F28 E3 N5 F47 S2
               R90 N2 L90 W4 L180 W3 F51 F77 L90 W5 N5 W3 S5 W5 R180 N1 W3 S5
               F36 W1 F34 N4 F40 E2 S3 R90 W5 S2 N4 R90 S2 L90 N4 L90 S2 E1 F2
               N4 F65 N1 F46 R180 F60 N4 F45 R90 S3 L90 F70 W4 L270 N4 F49 E3
               F52 R180 F5 E5 R90 F43 L90 S4 F54 N1 F7 S2 F91 S4 N3 E3 S4 L180
               F15 S2 F90 W5 S2 F80 N4 L90 R90 N4 E2 R180 E5 F62 L90 N5 F77 N5
               F75 E2 L90 S4 F55 E1 N5 F57 R90 F6 L90 N3 E5 L180 N2 L270 N5 F8
               E2 F88 E3 N3 E4 R90 N1 W5 R90 N4 E3 S3 R90 N1 E2 F4 N4 R90 N3 W5
               L180 E1 F2 N4 W5 F80 S4 F7 L180 F96 L90 F16 L90 E4 F78 W2 R90 S3
               F29 W4 R90 E4 F39 N1 F48 E4 L180 E1 R180 E2 R90 N3 R180 W2 N5 W5
               E3 F25 E1 L180 N5 F44 L90 N4 W4 L90 F72 L90 S1 E5 N5 R90 N1 W3
               S5 R90 W1 F14 L90 W2 R90 W3 F76 S5 W5 F93 W4 R90 F57 E3 R90 S3
               W1 R90 S3 F8 R90 N2 F46 W4 S1 L90 E4 W5 L90 W2 F69 N5 W5 F80 N3
               E4 L90 E4 F25 S3 R180 F77 R90 W2 F19 E4 L180 W2 F37 S2 F68 L90
               E2 F66 S1 R90 F66 E2 L180 F97 N3 W4 F43 S4 R180 N1 R270 E3 N2 N3
               F65 L90 S2 L90 N3 L90 S3 F23 L270 W3 S5 E2 R90 S1 F85 N3 R90 W4
               F58 E1 L90 N3 L90 E2 S1 F14 E2 N5 W1 N3 E1 L90 E3 F43 E3 N3 F21
               E4 F53 E2 L180 E4 F20 E2 N2 E5 L90 N4 W3 N4 S2 L90 W3 F96 L90 S3
               R90 N1 E3 S5 L270 F41 N5 W5 S1 W5 R90 F79 W3 L90 E3 F22 N1 L90
               E2 L90 R90 F20 L90 W3 R90 W2 L180 W4 F57 R180 N3 L90 F36 L90 E2
               R90 N2 E3 N1 W4 W4 N3 E5 F54 R180 F98 W1 R90 F21 S1 L90 S2 L90
               S2 F90 E4 S2 R90 N5 F25 N4 W3 N2 F27 S3 E3 N3 F15 L180 S4 F62 W2
               L180 E2 N2 L90 R90 F97 R90 S1 R90 E2 F16 W2 E1 F89 W1 L180 S3 W2
               S3 E1 F92 F30 N1 E2 S1 F76 E1 S5 W5 F28 W4 L90 F44 E4 N5 F25 R90
               F59 S4 F58 S2 F19 W5 S4 E5 N3 F37 E1 L90 F40 E5 F56 S2 W5 F73 N5
               F2 L90 F18 E2 N5 L90 F56 R90 F18 W1 S5 E1 N1 L90 W2 E4 N4 E1 W4
               N4 L90 N3 R90 W5 S5 F2 R180 F96 R90 W3 F26 L90 S4 E2 F43 S2 R90
               F61 W5 F93 R90 F95 L90 E4 R90 N4 F47 R90 W5 L90 F42 L90 W5 F87
               R90 N1 N2 E4 F64 S5 L270 F86 S4 W3 S1 L90 F72 R270 W1 F17 S1 E2
               R90 W1 N1 F42 N5 L90 F87 F66 L90 N2 W2 L90 S5 F7 R90 N4 L270 F2
               W1 N4 F94 W5 R180 S4 F15 E4 F76 N1 E2 F68 S3 F50 R270 E5 F77 R90
               S3 E2 N3 S4 F39 S1 E5 S3 L90 E4 S2 W3 F54 R90 F44 L90 W3 F59 R90
               N3 F37 E1 F75 R90 F31 W3 F70 S5 L90 E1 F67 W4 L90 S1 W5 S1 S4 W2
               E2 S3 R90 S2 E5 L90 F43 R90 E1 S5 F42 L90 W1 N2 E1 L180 S4 W1
               L90 F81 E1 R180 N5 R180 N5 L180 F65 R90 F64 W4 S4 R90 F70 E1 S1
               F50 E2 S4 E4 N2 S1 R90 E4 R90 F70 R90 N4 F71 R180 F80 S3 L90 N5
               L180 F11 N1 R90 W2 N1 R90 W4 R90 F67 W3 R90 W5 L90 E4 F90 L90 N4
               L180 F48 R90 W2 F94 R90 N4 L90 W2 F2 L90 W1 E5 S2 W5 S5 E2 N3 W5
               N1 F98 S3 W3 L90 S3 W4 R90 W1 F64 N5 R90 S5 W5 F84 S1 E3 L90 S3
               E5 F6 N4 W1 R90 E4 F14 N1 R90 F31 L90 F24 F4 N4 F54 S3 R270 F98
               E1 L180 F2 E4 F70 W1 R180 N5 F23)
#+end_example
** Test Cases
#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  (def-suite aoc.2020.12)
  (in-suite aoc.2020.12)

  (run! 'aoc.2020.12)
#+END_SRC
** Test Results
#+RESULTS: test-cases
** Thoughts
** Ada
*** Runner
Simple runner.
#+BEGIN_SRC ada :tangle ada/day12.adb
  with AOC2020.Day12;
  procedure Day12 is
  begin
    AOC2020.Day12.Run;
  end Day12;
#+END_SRC
*** Specification
Specification for solution.
#+BEGIN_SRC ada :tangle ada/aoc2020-day12.ads
  package AOC2020.Day12 is
     procedure Run;
  end AOC2020.Day12;
#+END_SRC
*** Packages
#+NAME: ada-packages
#+BEGIN_SRC ada
  with GNAT.Regpat; use GNAT.Regpat;
  with Text_IO; use Text_IO;
#+END_SRC
*** Types and generics
#+NAME: types-and-generics
#+BEGIN_SRC ada

#+END_SRC
*** Implementation
Actual implementation body.
#+BEGIN_SRC ada :tangle ada/aoc2020-day12.adb
  <<ada-packages>>
  package body AOC2020.Day12 is
     <<types-and-generics>>
     -- Used as an example of matching regular expressions
     procedure Parse_Line (Line : Unbounded_String; P : out Password) is
        Pattern : constant String := "(\d+)-(\d+) ([a-z]): ([a-z]+)";
        Re : constant Pattern_Matcher := Compile(Pattern);
        Matches : Match_Array (0..4);
        Pass : Unbounded_String;
        P0, P1 : Positive;
        C : Character;
     begin
        Match(Re, To_String(Line), Matches);
        P0 := Integer'Value(Slice(Line, Matches(1).First, Matches(1).Last));
        P1 := Integer'Value(Slice(Line, Matches(2).First, Matches(2).Last));
        C := Element(Line, Matches(3).First);
        Pass := To_Unbounded_String(Slice(Line, Matches(4).First, Matches(4).Last));
        P := (Min_Or_Pos => P0,
              Max_Or_Pos => P1,
              C => C,
              P => Pass);
     end Parse_Line;
     procedure Run is
     begin
        Put_Line("Advent of Code 2020 - Day 12");
        Put_Line("The result for Part 1 is " & Integer'Image(0));
        Put_Line("The result for Part 2 is " & Integer'Image(0));
     end Run;
  end AOC2020.Day12;
#+END_SRC
*** Run the program
In order to run this you have to "tangle" the code first using =C-c
C-v C-t=.

#+BEGIN_SRC shell :tangle no :results output :exports both
  cd ada
  gnatmake day12
  ./day12
#+END_SRC

#+RESULTS:
