#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 07
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2020-07)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
  (unless (find-package :series)
    (ql:quickload "series"))
  (unless (find-package :cl-permutation)
    (ql:quickload "cl-permutation"))
  (unless (find-package :bordeaux-threads)
    (ql:quickload "bordeaux-threads"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2020-07
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2020-07)
#+END_SRC
** Input
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect (parse-rule line))))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (read-input "input/07.txt"))
#+END_SRC
** Part 1
I have a =shiny gold= bag, and want to carry it in at least one other
bag. How many ways are there to carry it?

Each line specifies a bag and the bags it can hold. Time to break out
=cl-ppcre=. I'm able to 
#+NAME: rule-to-list
#+BEGIN_SRC lisp :results silent
  (defun parse-rule (rule)
    (list
     (let ((h (cl-ppcre:scan-to-strings "([a-z ]* bags contain)" rule)))
       (subseq h 0 (- (length h) 13)))
     (loop for m in (cl-ppcre:all-matches-as-strings "(\\d+ [a-z ]* bags?)" rule)
        for contains = (nth-value 1 (cl-ppcre:scan-to-strings "(\\d+) ([a-z ]+) bag" m))
        collect (list (parse-integer (elt contains 0))
                      (elt contains 1)))))
#+END_SRC

I'm moving slow today, so no reason to rush now. I want a count of,
directly or indirectly, how many bags can contain a =shiny gold=
bag. No need to bother with numbers. I'm going to do my usual hash
table as graph routine, it's convenient. I'll use the right hand side
(what each bag can contain) as the key, and the left hand side will be
part of the contents.

#+NAME: to-graph
#+BEGIN_SRC lisp :results silent
  (defun rules-to-graph (rules)
    (loop
       for (bag contains) in rules
       with graph = (make-hash-table :test #'equal)
       do (loop for (n b) in contains
             do (push bag (gethash b graph)))
       finally (return graph)))
#+END_SRC

#+NAME: count-containing-bags
#+BEGIN_SRC lisp :results silent
  (defun count-containing-bags (graph bag)
    (loop
       with queue = (list bag)
       with containing-bags = nil
       until (null queue)
       for next = (pop queue)
       do
         (loop for x in (gethash next graph)
            do (pushnew x queue)
              (pushnew x containing-bags))
       finally (return (values (length containing-bags) containing-bags))))
#+END_SRC
#+NAME: test-input
#+BEGIN_SRC lisp :results silent
  (defparameter *test-input* '(("light red" ((1 "bright white") (2 "muted yellow")))
                               ("dark orange" ((3 "bright white") (4 "muted yellow")))
                               ("bright white" ((1 "shiny gold")))
                               ("muted yellow" ((2 "shiny gold") (9 "faded blue")))
                               ("shiny gold" ((1 "dark olive") (2 "vibrant plum" )))
                               ("dark olive" ((3 "faded blue") (4 "dotted black")))
                               ("vibrant plum" ((5 "faded blue") (6 "dotted black")))
                               ("faded blue" ())
                               ("dotted black" ())))
#+END_SRC

#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a ()
    (format t "Problem 07 A: ~a~%"
            (count-containing-bags (rules-to-graph *input*) "shiny gold")))
#+END_SRC
** Part 2
Now we need to know how many bags the shiny bag has to contain. So
instead of inverting the graph (like above) I'll treat it as
presented. Still putting it into a hash table, and then writing a
recursive function.
#+NAME: counting-graph
#+BEGIN_SRC lisp :results silent
  (defun rules-to-counting-graph (rules)
    (loop with graph = (make-hash-table :test #'equal)
       finally (return graph)
       for (bag contains) in rules
       do (setf (gethash bag graph) contains)))
#+END_SRC

#+NAME: count-bags-in-bag
#+BEGIN_SRC lisp :results silent
  (defun count-bags-in-bag (graph bag)
     (loop for (c b) in (gethash bag graph)
        sum (* c (1+ (count-bags-in-bag graph b)))))
#+END_SRC

#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b ()
    (format t "Problem 07 B: ~a~%"
            (count-bags-in-bag (rules-to-counting-graph *input*) "shiny gold")))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<rule-to-list>>
  <<read-input>>
  <<input>>
  <<to-graph>>
  <<counting-graph>>
  <<count-bags-in-bag>>
  <<count-containing-bags>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle no
  <<initialize>>
  <<structs>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
: Problem 07 A: 213
: Problem 07 B: 38426
** Test Cases
#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both :noweb yes
  <<test-input>>
  (def-suite aoc.2020.07)
  (in-suite aoc.2020.07)
  (test part-1
    (is (= 4 (count-containing-bags (rules-to-graph *test-input*) "shiny gold"))))
  (run! 'aoc.2020.07)
#+END_SRC
** Test Results
#+RESULTS: test-cases
: 
: Running test suite AOC.2020.07
:  Running test PART-1 .
:  Did 1 check.
:     Pass: 1 (100%)
:     Skip: 0 ( 0%)
:     Fail: 0 ( 0%)
** Thoughts
** Ada
Simple runner.
#+BEGIN_SRC ada :tangle ada/day07.adb
  with AOC2020.Day07;
  procedure Day07 is
  begin
    null;
  end Day07;
#+END_SRC
Specification for solution.
#+BEGIN_SRC ada :tangle ada/aoc2020-day07.ads
  package AOC2020.Day07 is
     procedure Run;
  end AOC2020.Day07;
#+END_SRC
Actual implementation body.
#+BEGIN_SRC ada :tangle ada/aoc2020-day07.adb
  with GNAT.Regpat; use GNAT.Regpat;
  with Text_IO; use Text_IO;
  package body AOC2020.Day07 is
     -- Used as an example of matching regular expressions
     procedure Parse_Line (Line : Unbounded_String; P : out Password) is
        Pattern : constant String := "(\d+)-(\d+) ([a-z]): ([a-z]+)";
        Re : constant Pattern_Matcher := Compile(Pattern);
        Matches : Match_Array (0..4);
        Pass : Unbounded_String;
        P0, P1 : Positive;
        C : Character;
     begin
        Match(Re, To_String(Line), Matches);
        P0 := Integer'Value(Slice(Line, Matches(1).First, Matches(1).Last));
        P1 := Integer'Value(Slice(Line, Matches(2).First, Matches(2).Last));
        C := Element(Line, Matches(3).First);
        Pass := To_Unbounded_String(Slice(Line, Matches(4).First, Matches(4).Last));
        P := (Min_Or_Pos => P0,
              Max_Or_Pos => P1,
              C => C,
              P => Pass);
     end Parse_Line;
     procedure Run is
     begin
        null;
     end Run;
  end AOC2020.Day07;
#+END_SRC

In order to run this you have to "tangle" the code first using =C-c
C-v C-t=.

#+BEGIN_SRC shell :tangle no :results output :exports both
  cd ada
  gnatmake day07
  ./day07
#+END_SRC

#+RESULTS:
