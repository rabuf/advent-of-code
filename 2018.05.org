#+STARTUP: indent content
#+OPTIONS: num:nil toc:nil
* DONE Day 5
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by typing =C-c C-c= in the
block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
#+END_SRC

#+RESULTS: packages
| iterate |

*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes
  <<packages>>
  (defpackage :aoc-2018-05
    (:use :common-lisp
          :iterate)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-05)
#+END_SRC

#+RESULTS: initialize
: #<PACKAGE "AOC-2018-05">

** Input
The input is a single massive line of letters. So reading is easy.
#+NAME: read-input
#+BEGIN_SRC lisp
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes
  <<read-input>>
  (defvar *input*
    (car (read-input "input/2018/5.txt")))
#+END_SRC

** Part 1
Iterating over the sequence, we need to cancel out like terms (lower
case next to capital). I'm going to try something in iterate that may
work well for this.

Didn't work. Ok, thinking about this. Find a pair that match, remove
that pair. So we have to go character by character.
#+NAME: cancel-pairs
#+BEGIN_SRC lisp
  (defun cancel-pairs-iterative (polymer)
    (let ((i 0))
      (map 'string #'identity
           (iter (while (< i (length polymer)))
                 (cond ((= i (1- (length polymer)))
                        (collect (char polymer i))
                        (incf i))
                       (t
                        (let ((cn (char-int (char polymer i)))
                              (cn+1 (char-int (char polymer (1+ i)))))
                          (cond ((or (= (- cn (char-int #\a))
                                        (- cn+1 (char-int #\A)))
                                     (= (- cn (char-int #\A))
                                        (- cn+1 (char-int #\a))))
                                 (incf i 2))
                                (t (collect (char polymer i))
                                   (incf i))))))))))
  (defun cancel-pairs (polymer)
    (let ((current (length polymer))
          (previous 0))
      (iter (while (not (= current previous)))
            (progn
              (setf polymer (cancel-pairs-iterative  polymer))
              (setf previous current)
              (setf current (length polymer))))
      current))
#+END_SRC

#+RESULTS: cancel-pairs
: CANCEL-PAIRS

That took too long to come up with. Should've just done the recursive
thing to start with.
#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes
  (defun problem-a () (format t "Problem 5a: ~a~%" (cancel-pairs *input*)))
#+END_SRC
** Part 2
For this one, I have to remove all of one letter and see which produces the minimum. iterate will be helpful here.
#+NAME: remove-block
#+BEGIN_SRC lisp
  (defun remove-block (polymer)
    (iter (for l in-string "abcdefghijklmnopqrstuvwxyz")
          (for u in-string "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
          (minimizing (cancel-pairs (remove u (remove l polymer))))))
#+END_SRC

#+RESULTS: remove-block
: REMOVE-BLOCK

#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes
  (defun problem-b () (format t "Problem 5b: ~a~%" (remove-block *input*)))
#+END_SRC
** Putting it all together
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes
  <<cancel-pairs>>
  <<remove-block>>
#+END_SRC

#+RESULTS: functions
: REMOVE-BLOCK

#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.05.lisp
  <<initialize>>
  <<input>>
  <<functions>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
: Problem 5a: 11310
: Problem 5b: 6020
** Thoughts
