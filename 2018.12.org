#+STARTUP: indent contents
#+OPTIONS: num:nil toc:nil
* Day 12
** Executing this code
If you have a lisp installation, emacs, org-mode, and org-babel
support for lisp installed you can run this by:
1. Starting slime (=M-x slime=)
2. Typing =C-c C-c= in the block [[initialize][initialize]].
3. In the repl type =(in-package :aoc-2018-12)=
4. Typing =C-c C-c= in the block [[answers][answers]]
** Initial stuffs
*** Packages to load
#+NAME: packages
#+BEGIN_SRC lisp :results silent
  (unless (find-package :cl-ppcre)
    (ql:quickload "cl-ppcre"))
  (unless (find-package :iterate)
    (ql:quickload "iterate"))
  (unless (find-package :parseq)
    (ql:quickload "parseq"))
  (unless (find-package :fiveam)
    (ql:quickload "fiveam"))
#+END_SRC
*** Create package for this day
#+NAME: initialize
#+BEGIN_SRC lisp :noweb yes :results silent
  <<packages>>
  (defpackage :aoc-2018-12
    (:use :common-lisp
          :iterate
          :parseq
          :fiveam)
    (:export :problem-a
             :problem-b))
  (in-package :aoc-2018-12)
#+END_SRC
** Input
#+NAME: read-input
#+BEGIN_SRC lisp :results silent
  (defun read-input (file)
    (iter (for line in-file file using #'read-line)
          (collect line)))
#+END_SRC
#+NAME: input
#+BEGIN_SRC lisp :noweb yes :results silent
  (defparameter *input*
    (read-input "input/12.txt"))
#+END_SRC
** Part 1
This is a simple rules-based simulator like the game of life. For each
pot (cell) determine whether it lives or dies per the list of rules
(they are complete).

There are an infinite number of pots so the rules may cause plants to
appear outside the span of the input itself.

The question is how many plants are alive after generation 20.
#+NAME: problem-a
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-a () (format t "Problem 12 A: ~a~%" (identity *input*)))
#+END_SRC
** Part 2
#+NAME: problem-b
#+BEGIN_SRC lisp :noweb yes :results silent
  (defun problem-b () (format t "Problem 12 B: ~a~%" (identity *input*)))
#+END_SRC
** Putting it all together
#+NAME: structs
#+BEGIN_SRC lisp :noweb yes :results silent

#+END_SRC
#+NAME: functions
#+BEGIN_SRC lisp :noweb yes :results silent
  <<read-input>>
#+END_SRC
#+NAME: answers
#+BEGIN_SRC lisp :results output :exports both :noweb yes :tangle 2018.12.lisp
  <<initialize>>
  <<functions>>
  <<input>>
  <<problem-a>>
  <<problem-b>>
  (problem-a)
  (problem-b)
#+END_SRC
** Answer
#+RESULTS: answers
#+begin_example
Problem 12 A: (initial state: .##..#.#..##..##..##...#####.#.....#..#..##.###.#.####......#.......#..###.#.#.##.#.#.###...##.###.#
                .##.# => # ##.#. => # ##... => # #.... => . .#..# => .
               #.##. => . .##.. => . .#.## => . ###.. => . ..##. => #
               ##### => # #...# => # .#... => # ###.# => # #.### => #
               ##..# => . .###. => # ...## => . ..#.# => . ##.## => #
               ....# => . #.#.# => # #.#.. => . .#### => . ...#. => #
               ..### => . ..#.. => # ..... => . ####. => . #..## => #
               .#.#. => . #..#. => #)
Problem 12 B: (initial state: .##..#.#..##..##..##...#####.#.....#..#..##.###.#.####......#.......#..###.#.#.##.#.#.###...##.###.#
                .##.# => # ##.#. => # ##... => # #.... => . .#..# => .
               #.##. => . .##.. => . .#.## => . ###.. => . ..##. => #
               ##### => # #...# => # .#... => # ###.# => # #.### => #
               ##..# => . .###. => # ...## => . ..#.# => . ##.## => #
               ....# => . #.#.# => # #.#.. => . .#### => . ...#. => #
               ..### => . ..#.. => # ..... => . ####. => . #..## => #
               .#.#. => . #..#. => #)
#+end_example
** Test Cases
#+NAME: test-cases
#+BEGIN_SRC lisp :results output :exports both
  (def-suite aoc.2018.12)
  (in-suite aoc.2018.12)

  (run! 'aoc.2018.12)
#+END_SRC
** Test Results
#+RESULTS: test-cases
** Thoughts
